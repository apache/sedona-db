% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expression.R
\name{sd_expr_column}
\alias{sd_expr_column}
\alias{sd_expr_literal}
\alias{sd_expr_binary}
\alias{sd_expr_negative}
\alias{sd_expr_scalar_function}
\alias{sd_expr_aggregate_function}
\alias{sd_expr_cast}
\alias{sd_expr_alias}
\alias{as_sd_expr}
\alias{is_sd_expr}
\alias{sd_expr_factory}
\title{Create SedonaDB logical expressions}
\usage{
sd_expr_column(column_name, qualifier = NULL, factory = sd_expr_factory())

sd_expr_literal(x, type = NULL, factory = sd_expr_factory())

sd_expr_binary(op, lhs, rhs, factory = sd_expr_factory())

sd_expr_negative(expr, factory = sd_expr_factory())

sd_expr_scalar_function(function_name, args, factory = sd_expr_factory())

sd_expr_aggregate_function(
  function_name,
  args,
  ...,
  na.rm = FALSE,
  distinct = FALSE,
  factory = sd_expr_factory()
)

sd_expr_cast(expr, type, factory = sd_expr_factory())

sd_expr_alias(expr, alias, factory = sd_expr_factory())

as_sd_expr(x, factory = sd_expr_factory())

is_sd_expr(x)

sd_expr_factory(ctx = NULL)
}
\arguments{
\item{column_name}{A column name}

\item{qualifier}{An optional qualifier (e.g., table reference) that may be
used to disambiguate a specific reference}

\item{factory}{A \code{\link[=sd_expr_factory]{sd_expr_factory()}}. This factory wraps a SedonaDB context
and is used to resolve scalar functions and/or retrieve options.}

\item{type}{A destination type into which \code{expr} should be cast.}

\item{op}{Operator name for a binary expression. In general these follow
R function names (e.g., \code{>}, \code{<}, \code{+}, \code{-}).}

\item{lhs, rhs}{Arguments to a binary expression}

\item{expr}{A SedonaDBExpr or object coercible to one with \code{\link[=as_sd_expr]{as_sd_expr()}}.}

\item{function_name}{The name of the function to call. This name is resolved
from the context associated with \code{factory}.}

\item{args}{A list of SedonaDBExpr or object coercible to one with
\code{\link[=as_sd_expr]{as_sd_expr()}}.}

\item{...}{Reserved for future use}

\item{na.rm}{For aggregate expressions, should nulls be ignored? The R
idiom is to respect null; however, the SQL idiom is to drop them. The
default value follows the R idiom (\code{na.rm = FALSE}).}

\item{distinct}{For aggregate expressions, use only distinct values.}

\item{alias}{An alias to apply to \code{expr}.}

\item{ctx}{A SedonaDB context or NULL to use the default context.}
}
\value{
An object of class SedonaDBExpr
}
\description{
Create SedonaDB logical expressions
}
\examples{
sd_expr_column("foofy")
sd_expr_literal(1L)
sd_expr_scalar_function("abs", list(1L))
sd_expr_cast(1L, nanoarrow::na_int64())
sd_expr_alias(1L, "foofy")

}
